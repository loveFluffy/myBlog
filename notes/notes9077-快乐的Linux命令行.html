<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../stylesheets/notestyles.css" />
    <title>快乐的Linux命令行</title>
    <link rel="icon" href="../images/x.ico" />
</head>
<body> <!-- CHANGE HERE -->
    <h1>Notes#9077: 快乐的Linux命令行</h1>
    <h2>http://billie66.github.io/TLCL/</h2>



    <!-- ======================== Ch1: 引言 ======================== -->
    <h3>Ch1: 引言</h3>



    <!-- ======================== Ch2: 什么是Shell ======================== -->
    <h3>Ch2: 什么是Shell</h3>
    <div>
        <h4>2.5 关于鼠标和光标</h4>
        <p>X窗口系统（使GUI工作的底层引擎）内建了一种机制，支持快速拷贝和粘贴技巧。如果你想高亮一些文本，可以按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词），那么这些高亮的文本就被拷贝到了一个由X管理的缓冲区里面。然后按下鼠标中键，这些文本就被粘贴到光标所在的位置。</p>
        <p>设置聚焦策略为“聚焦跟随着鼠标”，可以使拷贝和粘贴技巧更有益。在窗口管理器的配置程序中，你会找到这个设置。</p>

        <h4>2.6 试试运行一些简单命令</h4>
        <ul>
            <li>$ date 显示系统当前时间和日期；</li>
            <li>$ cal 默认显示当前的月份；</li>
            <li>$ df 查看磁盘剩余空间数量；</li>
            <li>$ free 查看空闲内存的数量；</li>
        </ul>

        <h4>2.8 幕后控制台</h4>
        <p>在大多数Linux发行版中，按下Ctrl-Alt-F1到Ctrl-Alt-F6访问不同的虚拟终端。当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。从一个虚拟控制台转换到另一个，按下Alt和F1-F6中的一个。返回图形桌面，按下 Alt-F7。</p>
    </div>



    <!-- ======================== Ch3: 文件系统中跳转 ======================== -->
    <h3>Ch3: 文件系统中跳转</h3>
    <div>
        <h4>3.2 当前工作目录</h4>
        <p>我们使用pwd (print working directory) 命令，来显示当前工作目录。</p>

        <h4>3.7 有用的快捷键</h4>
        <ul>
            <li>$ cd 更改工作目录到你的家目录；</li>
            <li>$ cd - 更改工作目录到先前的工作目录；</li>
            <li>$ cd ~user_name 更改工作目录到用户家目录。例如，cd ～bob 会更改工作目录到用户“bob”的家目录；</li>
        </ul>
        <p>用ls -a 命令列出隐藏文件。</p>
    </div>



    <!-- ======================== Ch4: 探究操作系统 ======================== -->
    <h3>Ch4: 探究操作系统</h3>
    <div>
        <h4>4.4 确定文件类型</h4>
        <p>$ file filename 调用file命令。</p>

        <h4>4.5 用less浏览文件内容</h4>
        <p>许多包含系统设置的文件（叫做配置文件），是以文本格式存储的，阅读它们可以更深入的了解系统是如何工作的。</p>
        <p>$ less filename</p>
        <p align="center"><strong>less程序最常用的键盘命令</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>命令</th>
                <th>行为</th>
            </tr>

            <tr>
                <td>Page Up or b</td>
                <td>向上翻滚一页</td>
            </tr>
            <tr>
                <td>Page Down or space</td>
                <td>向下翻滚一页</td>
            </tr>
            <tr>
                <td>Up Arrow</td>
                <td>向上翻滚一行</td>
            </tr>
            <tr>
                <td>Down Arrow</td>
                <td>向下翻滚一行</td>
            </tr>
            <tr>
                <td>G</td>
                <td>移动到最后一行</td>
            </tr>
            <tr>
                <td>1G or g</td>
                <td>移动到开头一行</td>
            </tr>
            <tr>
                <td>/characters</td>
                <td>向前查找指定的字符串</td>
            </tr>
            <tr>
                <td>n</td>
                <td>向前查找下一个出现的字符串，这个字符串是之前所指定查找的</td>
            </tr>
            <tr>
                <td>h</td>
                <td>显示帮助屏幕</td>
            </tr>
            <tr>
                <td>q</td>
                <td>退出less程序</td>
            </tr>
        </table>
        
        <h4>4.7 旅行指南</h4>
        <p align="center"><strong>Linux系统目录介绍</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>目录</th>
                <th>评论</th>
            </tr>

            <tr>
                <td>/</td>
                <td>根目录，万物起源。</td>
            </tr>
            <tr>
                <td>/bin</td>
                <td>包含系统启动和运行所必须的二进制程序。</td>
            </tr>
            <tr>
                <td>/boot</td>
                <td>包含Linux内核，最初的RMA磁盘映像（系统启动时，由驱动程序所需），和启动加载程序。<br/>
                    有趣的文件：<br/>
                    <ul>
                        <li>/boot/grub/grub.conf or menu.lst，被用来配置启动加载程序。</li>
                        <li>/boot/vmlinuz，Linux内核。</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>/dev</td>
                <td>这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。在这个目录里，内核维护着它支持的设备。</td>
            </tr>
            <tr>
                <td>/etc</td>
                <td>这个目录包含所有系统层面的配置文件。它也包含一系列的shell脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。<br/>
                    有意思的文件：<br/>
                    虽然/etc目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：<br/>
                    <ul>
                        <li>/etc/crontab，定义自动运行的任务。</li>
                        <li>/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。</li>
                        <li>/etc/passwd，包含用户帐号列表。</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>/home</td>
                <td>在通常的配置环境下，系统会在/home下，给每个用户分配一个目录。普通用户只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。</td>
            </tr>
            <tr>
                <td>/lib</td>
                <td>包含核心系统程序所需的库文件。这些文件与Windows中的动态链接库相似。</td>
            </tr>
            <tr>
                <td>/lost+found</td>
                <td>每个使用Linux文件系统的格式化分区或设备，例如ext3文件系统，都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文件系统真正的损坏了，那么这个目录会是个空目录。</td>
            </tr>
            <tr>
                <td>/media</td>
                <td>在现在的Linux系统中，/media目录会包含可移除媒体设备的挂载点，例如USB驱动器，CDROMs等等。这些设备连接到计算机之后， 会自动地挂载到这个目录结点下。</td>
            </tr>
            <tr>
                <td>/mnt</td>
                <td>在早些的Linux系统中，/mnt目录包含可移除设备的挂载点。</td>
            </tr>
            <tr>
                <td>/opt</td>
                <td>这个/opt目录被用来安装“可选的”软件。这个主要用来存储可能安装在系统中的商业软件产品。</td>
            </tr>
            <tr>
                <td>/proc</td>
                <td>这个/proc目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。反而，它是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的，它们会告诉你内核是怎样监管计算机的。</td>
            </tr>
            <tr>
                <td>/root</td>
                <td>root帐户的主目录。</td>
            </tr>
            <tr>
                <td>/sbin</td>
                <td>这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。</td>
            </tr>
            <tr>
                <td>/tmp</td>
                <td>这个/tmp目录，是用来存储由各种程序创建的临时文件的地方。一些配置，导致系统每次重新启动时，都会清空这个目录。</td>
            </tr>
            <tr>
                <td>/usr</td>
                <td>在Linux系统中，/usr目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。</td>
            </tr>
            <tr>
                <td>/usr/bin</td>
                <td>/usr/bin目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。</td>
            </tr>
            <tr>
                <td>/usr/lib</td>
                <td>包含由/usr/bin目录中的程序所用的共享库。</td>
            </tr>
            <tr>
                <td>/usr/local</td>
                <td>这个/usr/local目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。通常，由源码编译的程序会安装在/usr/local/bin目录下。新安装的Linux系统中，会存在这个目录，但却是空目录，直到系统管理员放些东西到它里面。</td>
            </tr>
            <tr>
                <td>/usr/sbin</td>
                <td>包含许多系统管理程序。</td>
            </tr>
            <tr>
                <td>/usr/share</td>
                <td>/usr/share目录包含许多由/usr/bin目录中的程序使用的共享数据。其中包括像默认的配置文件，图标，桌面背景，音频文件等等。</td>
            </tr>
            <tr>
                <td>/usr/share/doc</td>
                <td>大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下，我们可以找到按照软件包分类的文档。</td>
            </tr>
            <tr>
                <td>/var</td>
                <td>除了/tmp和/home目录之外，相对来说，目前我们看到的目录是静态的，这是说，它们的内容不会改变。/var目录是可能需要改动的文件存储的地方。各种数据库，假脱机文件，用户邮件等等，都驻扎在这里。</td>
            </tr>
            <tr>
                <td>/var/log</td>
                <td>这个/var/log目录包含日志文件，各种系统活动的记录。这些文件非常重要，并且应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中，你必须是超级用户才能查看这些日志文件。</td>
            </tr>
        </table>
    </div>



    <!-- ======================== Ch5: 操作文件和目录 ======================== -->
    <h3>Ch5: 操作文件和目录</h3>
    <div>
        <h4>5.1 通配符</h4>
        <p align="center"><strong>通配符列表</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>通配符</th>
                <th>意义</th>
            </tr>

            <tr>
                <td>*</td>
                <td>匹配任意多个字符（包括零个或一个）</td>
            </tr>
            <tr>
                <td>?</td>
                <td>匹配任意一个字符（不包括零个）</td>
            </tr>
            <tr>
                <td>[characters]</td>
                <td>匹配任意一个属于字符集中的字符</td>
            </tr>
            <tr>
                <td>[!characters]</td>
                <td>匹配任意一个不是字符集中的字符</td>
            </tr>
            <tr>
                <td>[[:class:]]</td>
                <td>匹配任意一个属于指定字符类中的字符</td>
            </tr>
        </table>

        <p align="center"><strong>普遍使用的字符类</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>字符类</th>
                <th>意义</th>
            </tr>

            <tr>
                <td>[:alnum:]</td>
                <td>匹配任意一个字母或数字</td>
            </tr>
            <tr>
                <td>[:alpha:]</td>
                <td>匹配任意一个字母</td>
            </tr>
            <tr>
                <td>[:digit:]</td>
                <td>匹配任意一个数字</td>
            </tr>
            <tr>
                <td>[:lower:]</td>
                <td>匹配任意一个小写字母</td>
            </tr>
            <tr>
                <td>[:upper]</td>
                <td>匹配任意一个大写字母</td>
            </tr>
        </table>

        <p align="center"><strong>通配符范例</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>模式</th>
                <th>匹配对象</th>
            </tr>

            <tr>
                <td>*</td>
                <td>所有文件</td>
            </tr>
            <tr>
                <td>g*</td>
                <td>文件名以“g”开头的文件</td>
            </tr>
            <tr>
                <td>b*.txt</td>
                <td>以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件</td>
            </tr>
            <tr>
                <td>Data???</td>
                <td>以“Data”开头，其后紧接着3个字符的文件</td>
            </tr>
            <tr>
                <td>[abc]*</td>
                <td>文件名以"a","b",或"c"开头的文件</td>
            </tr>
            <tr>
                <td>BACKUP.[0-9][0-9][0-9]</td>
                <td>以"BACKUP."开头，并紧接着3个数字的文件</td>
            </tr>
            <tr>
                <td>[[:upper:]]*</td>
                <td>以大写字母开头的文件</td>
            </tr>
            <tr>
                <td>[![:digit:]]*</td>
                <td>不以数字开头的文件</td>
            </tr>
            <tr>
                <td>*[[:lower:]123]</td>
                <td>文件名以小写字母结尾，或以“1”，“2”，或“3”结尾的文件</td>
            </tr>
        </table>

        <h4>5.2 mkdir 创建目录</h4>

        <h4>5.3 cp 复制文件和目录</h4>

        <h4>5.5 mv 移动和重命名文件</h4>
        
        <h4>5.7 rm 删除文件和目录</h4>
        
        <h4>5.9 ln 创建链接</h4>
        <ul>
            <li>$ ln file link 创建硬链接；</li>
            <li>$ ln -s item link 创建符号链接，item可以是文件或者目录；</li>
        </ul>

        <h4>5.10 硬链接</h4>
        <p>硬链接是最初Unix创建链接的方式，而符号链接更加现代。在默认情况下，每个文件有一个硬链接，这个硬链接给文件起名字。当我们创建一个硬链接以后，就为文件创建了一个额外的目录条目。<br/>
        硬链接有两个重要局限性：<br/>
        1. 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联与链接本身不在同一个磁盘分区上的文件。<br/>
        2. 一个硬链接不能关联一个目录。</p>
        <p>一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录内容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件的链接都删除掉。知道硬链接很重要，因为你可能有时会遇到它们，但现在实际中更喜欢使用符号链接。</p>

        <h4>5.11 符号链接</h4>
        <p>创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。在这一方面，它们和 Windows 的快捷方式差不多，当然，符号链接早于Windows的快捷方式很多年;-)</p>
        <p>一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果删除这个文件早于文件的符号链接，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中，ls命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。</p>

        <h4>5.15 创建硬链接</h4>
        <p>你要记得一个文件至少有一个硬链接，因为文件名就是由链接创建的。</p>
        <p>ls命令有一种方法，来展示（文件索引节点）的信息。在命令中加上"-i"选项：<br/>
        [me@linuxbox playground]$ ls -li<br/>
        total 16<br/>
        12353538 -rw-r--r-- 4 me me 1650 2008-01-10 16:33 fun<br/>
        12353538 -rw-r--r-- 4 me me 1650 2008-01-10 16:33 fun-hard<br/>
        在这个版本的列表中，第一字段表示文件索引节点号，正如我们所见到的，fun和fun-hard共享一样的索引节点号，这就证实这两个文件是一样的文件。</p>

        <h4>5.17 移动文件和目录</h4>
        <p>对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。而rm命令是个特例。当你删除链接的时候， 删除链接本身，而不是链接的对象。</p>
        <p>文件管理器GNOME和KDE都提供了一个简单而且自动化的方法来创建符号链接。在GNOME里面，当拖动文件时，同时按下Ctrl+Shift按键会创建一个链接，而不是复制（或移动）文件。</p>
    </div>



    <!-- ======================== Ch6: 使用命令 ======================== -->
    <h3>Ch6: 使用命令</h3>
    <div>
        <h4>6.1 到底什么是命令？</h4>
        <p>可以是下面四种形式之一：
            <ul>
                <li>1. 是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用C和C++语言写成的程序，也可以是由脚本语言写成的程序，比如说shell，perl，python，ruby，等等。</li>
                <li>2. 是一个内建于shell自身的命令。bash支持若干命令，内部叫做shell内部命令(builtins)。例如，cd命令，就是一个shell内部命令。</li>
                <li>3. 是一个shell函数。这些是小规模的shell脚本，它们混合到环境变量中。在后续的章节里，我们将讨论配置环境变量以及书写shell函数。但是现在，仅仅意识到它们的存在就可以了。</li>
                <li>4. 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。</li>
            </ul>
        </p>
        
        <h4>6.3 type 显示命令的类型</h4>
        <p>$ type command</p>

        <h4>6.4 which 显示一个可执行程序的位置</h4>

        <h4>6.8 man 显示程序手册页</h4>
        <p>在大多数Linux系统中，man使用less工具来显示参考手册，所以当浏览文档时，你所熟悉的less命令都能有效。</p>
        <p align="center"><strong>man 所显示的手册页的布局</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>章节</th>
                <th>内容</th>
            </tr>

            <tr>
                <td>1</td>
                <td>用户命令</td>
            </tr>
            <tr>
                <td>2</td>
                <td>程序接口内核系统调用</td>
            </tr>
            <tr>
                <td>3</td>
                <td>C 库函数程序接口</td>
            </tr>
            <tr>
                <td>4</td>
                <td>特殊文件，比如说设备结点和驱动程序</td>
            </tr>
            <tr>
                <td>5</td>
                <td>文件格式</td>
            </tr>
            <tr>
                <td>6</td>
                <td>游戏娱乐，如屏幕保护程序</td>
            </tr>
            <tr>
                <td>7</td>
                <td>其他方面</td>
            </tr>
            <tr>
                <td>8</td>
                <td>系统管理员命令</td>
            </tr>
        </table>
        <p>使用man命令来指定章节号：$ man section search_term<br/>
        例如：$ man 5 passwd 会显示文件/etc/passwd的文件格式说明手册。</p>

        <h4>6.9 apropos 显示适当的命令</h4>
        <p>以“floppy”为关键词来搜索参考手册的例子：$ apropos floppy</p>
        <p>man 命令加上“-k”选项，和apropos完成一样的功能。</p>

        <h4>6.10 whatis 显示非常简洁的命令说明</h4>

        <h4>6.11 info 显示程序Info条目</h4>
        <p>info页是超级链接形式的，和网页很相似。</p>
        <p>info程序读取info文件，info文件是树型结构，分化为各个结点，每一个包含一个题目。info文件包含超级链接，它可以让你从一个结点跳到另一个结点。一个超级链接可通过它开头的星号来辨别出来，把光标放在它上面并按下enter键，就可以激活它。</p>
        <p align="center"><strong>info 命令</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>命令</th>
                <th>行为</th>
            </tr>

            <tr>
                <td>?</td>
                <td>显示命令帮助</td>
            </tr>
            <tr>
                <td>PgUp or Backspace</td>
                <td>显示上一页</td>
            </tr>
            <tr>
                <td>PgDn or Space</td>
                <td>显示下一页</td>
            </tr>
            <tr>
                <td>n</td>
                <td>下一个-显示下一个结点</td>
            </tr>
            <tr>
                <td>p</td>
                <td>上一个-显示上一个结点</td>
            </tr>
            <tr>
                <td>u</td>
                <td>Up-显示当前所显示结点的父结点，通常是个菜单</td>
            </tr>
            <tr>
                <td>Enter</td>
                <td>激活光标位置下的超级链接</td>
            </tr>
            <tr>
                <td>q</td>
                <td>退出</td>
            </tr>
        </table>
        <p>到目前为止，我们所讨论的大多数命令行程序，属于GNU项目"coreutils"包，所以输入：<br/>
        $ info coreutils<br/>
        将会显示一个包含超级链接的手册页，这些超级链接指向包含在coreutils包中的各个程序。</p>

        <h4>6.12 README和其它程序文档</h4>
        <p>许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc目录下。这些文件大多数是以文本文件的形式存储的，可用less阅读器来浏览。一些文件是HTML格式，可用网页浏览器来阅读。我们可能遇到许多以".gz"结尾的文件。这表示gzip压缩程序已经压缩了这些程序。gzip 软件包包括一个特殊的less版本，叫做zless，zless 可以显示由gzip 压缩的文本文件的内容。</p>

        <h4>6.13 用别名（alias）创建你自己的命令</h4>
        <p>$ alias name='string'</p>
        <p>删除别名，使用unalias命令。</p>
    </div>



    <!-- ======================== Ch7: 重定向 ======================== -->
    <h3>Ch7: 重定向</h3>
    <div>
        <h4>7.2 重定向标准输出</h4>
        <p>举例：$ ls -l > ls-output.txt</p>
        <p>一个删除文件内容或者创建一个新的空文件的技巧：$ >ls-output.txt<br/>
            简单地使用重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是创建一个新的空文件。这是因为，当我们使用">"重定向符来重定向输出结果时，目标文件总是从开头被重写。</p>
        <p>用">>"重定向符可以把重定向结果追加到文件内容后面，而不是从开头重写文件。</p>

        <h4>7.3 重定向标准错误</h4>
        <p>重定向标准错误缺乏专用的重定向操作符。重定向标准错误，我们必须参考它的文件描述符。一个程序可以在几个编号的文件流中的任一个上产生输出。然而我们必须把这些文件流的前三个看作标准输入，输出和错误，shell内部参考它们为文件描述符0，1和2，各自地。shell提供了一种表示法来重定向文件，使用文件描述符。因为标准错误和文件描述符2一样，我们用这种表示法来重定向标准错误：<br/>
        $ ls -l /bin/usr 2> ls-error.txt<br/>
        文件描述符"2"，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件ls-error.txt任务。</p>

        <h4>7.4 重定向标准输出和错误到同一个文件</h4>
        <p>有两种方法来完成任务。</p>
        <p>第一个，传统的方法，在旧版本shell中也有效：<br/>
            $ ls -l /bin/usr > ls-output.txt 2>&1<br/>
            使用这种方法，我们完成两个重定向。首先重定向标准输出到文件ls-output.txt，然后重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。</p>
        <p>注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后，要不然它不起作用。上面的例子，<br/>
        >ls-output.txt 2>&1<br/>
        重定向标准错误到文件ls-output.txt，但是如果命令顺序改为：<br/>
        2>&1 >ls-output.txt<br/>
        则标准错误定向到屏幕。</p>
        <p>现在的bash版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。<br/>
        $ ls -l /bin/usr &> ls-output.txt<br/>
        在这个例子里面，我们使用单单一个表示法 &> 来重定向标准输出和错误到文件ls-output.txt。</p>

        <h4>7.5 处理不需要的输出</h4>
        <p>重定向到/dev/null中去。举例：$ ls -l /bin/usr 2> /dev/null</p>

        <h4>7.7 cat 连接文件</h4>
        <p>cat 命令读取一个或多个文件，然后复制它们到标准输出。</p>
        <p>cat经常被用来显示简短的文本文件。因为cat可以接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。</p>
        <p>比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET中的多媒体文件经常以这种方式分离），我们想把它们连起来。<br/>
            我们能用这个命令把它们连接起来：<br/>
            cat movie.mpeg.0* > movie.mpeg<br/>
        因为通配符总是以有序的方式展开， 所以这些参数会以正确顺序安排。</p>
        <p>如果我们输入不带参数的"cat"命令， 会发生什么呢：<br/>
            [me@linuxbox ~]$ cat<br/>
            没有发生任何事情，它只是坐在那里，好像挂掉了一样。看起来是那样，但是它正在做它该做的事情：如果cat没有给出任何参数，它会从标准输入读入数据，因为标准输入，默认情况下，连接到键盘。它正在等待我们输入数据！试试这个：<br/>
            [me@linuxbox ~]$ cat<br/>
            The quick brown fox jumped over the lazy dog.<br/>
            下一步，输入 Ctrl-d（按住 Ctrl 键同时按下"d"），来告诉cat，在标准输入中，它已经到达文件末尾（EOF）：由于文件名参数的缺席，cat复制标准输入到标准输出，所以我们看到文本行重复出现。<br/>
            我们可以使用这种行为来创建简短的文本文件。比方说，我们想创建一个叫做"lazy_dog.txt"的文件，这个文件包含例子中的文本。我们这样做：<br/>
            [me@linuxbox ~]$ cat > lazy_dog.txt<br/>
            The quick brown fox jumped over the lazy dog.<br/>
            输入命令，其后输入要放入文件中的文本。记住，最后输入 Ctrl-d。通过使用这个命令，我们实现了世界上最低能的文字处理器！ <br/>
            现在我们知道怎讲接受标准输入，除了文件名参数，让我们试着重定向标准输入：<br/>
            [me@linuxbox ~]$ cat < lazy_dog.txt<br/>
            The quick brown fox jumped over the lazy dog.<br/>
            使用“<”重定向操作符，我们把标准输入源从键盘改到文件lazy_dog.txt，我们看到结果和传递单个文件名作为参数的执行结果一样。把这和传递一个文件名参数作比较，尤其没有意义，但它是用来说明把一个文件作为标准输入源。</p>

        <h4>7.8 管道线</h4>

        <h4>7.9 过滤器</h4>
        <p>把目录/bin 和/usr/bin 中的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：<br/>
            $ ls /bin /usr/bin | sort | less</p>

        <h4>7.10 uniq 报道或忽略重复行</h4>
        <p>一个很实用的组合命令：<br/>
        $ ls /bin /usr/bin | sort | uniq | less</p>
        <p>如果我们想看到重复的数据列表，让uniq命令带上"-d"选项。</p>

        <h4>7.11 wc 打印行数，字数和字节数</h4>
        <p>例如：$ wc ls-output.txt <br/>
            7902 64566 503634 ls-output.txt</p>
        <p>"-l"选项限制命令输出只能报道行数。添加wc到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数，我们可以这样做：<br/>
        $ ls /bin /usr/bin | sort | uniq | wc -l <br/>
        2728</p>

        <h4>7.12 grep 打印匹配行</h4>
        <p>grep pattern [file...]</p>
        <p>grep有两个很方便的选项： <br/>
            "-i"导致 grep 忽略大小写当执行搜索时（通常，搜索是大小写敏感的）；<br/>
            "-v"选项会告诉grep只打印不匹配的行。</p>

        <h4>7.13 head/tail 打印文件开头部分/结尾部分</h4>
        <p>默认情况下，两个命令都打印十行文本，但是可以通过"-n"选项来调整命令打印的行数。<br/>
        $ head -n 5 ls-output.txt<br/>
        $ tail -n 5 ls-output.txt</p>
        <p>tail有一个-f选项允许你实时的浏览文件。使用"-f"选项，tail命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入Ctrl-c。[Bliss：这个功能测试失败。]</p>

        <h4>7.14 tee 从stdin读取数据，并同时输出到stdout和文件</h4>
        <p>tee程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。</p>
        <p>例如： $ ls /usr/bin | tee ls.txt | grep zip</p>
    </div>



    <!-- ======================== Ch8: 从shell眼中看世界 ======================== -->
    <h3>Ch8: 从shell眼中看世界</h3>
    <div>
        <h4>8.1 （字符）展开</h4>
        <p>$ echo *<br/>
            Desktop Documents ls-output.txt Music Pictures Public Templates Videos<br/>
        为什么 echo 不打印"*"呢？在echo命令被执行前。当回车键被按下时，shell在命令被执行前在命令行上自动展开任何符合条件的字符，所以echo命令从不会发现"*"，只把它展开成结果。 </p>

        <h4>8.2 路径名展开</h4>
        <p>例如：</p>
        <p>$ echo D* <br/>
        Desktop Documents</p>
        <p>$ echo *s<br/>
        Documents Pictures Templates Videos</p>
        <p>$ echo [[:upper:]]*<br/>
        Desktop Documents Music Pictures Public Templates Videos</p>
        <p>$ echo /usr/*/share<br/>
        /usr/kerberos/share /usr/local/share</p>
        <p>带有 -A 选项（almost all）的ls命令能够提供一份正确的隐藏文件清单。</p>

        <h4>8.3 波浪线展开</h4>
        <p>波浪线字符("~")有特殊的意思。当它用在一个单词的开头时，它会展开成指定用户的主目录名，如果没有指定用户名，则是当前用户的主目录。</p>
        <p>$ echo ~<br/>
        /home/me</p>
        <p>如果有用户"foo"这个帐号，然后：<br/>
        $ echo ~foo<br/>
        /home/foo</p>

        <h4>8.4 算术表达式展开</h4>
        <p>$((expression))</p>
        <p>算术表达式只支持整数（全部是数字，不带小数点）！</p>
        <p align="center"><strong>算术操作符</strong></p>
        <table align="center" border="1" width="80%">
            <tr align="center">
                <th>操作符</th>
                <th>说明</th>
            </tr>

            <tr>
                <td>+</td>
                <td>加</td>
            </tr>
            <tr>
                <td>-</td>
                <td>减</td>
            </tr>
            <tr>
                <td>*</td>
                <td>乘</td>
            </tr>
            <tr>
                <td>/</td>
                <td>除（但是记住，因为展开只是支持整数除法，所以结果是整数。）</td>
            </tr>
            <tr>
                <td>%</td>
                <td>取余</td>
            </tr>
            <tr>
                <td>**</td>
                <td>取幂</td>
            </tr>
        </table>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>
        
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>
        
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>
        
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>
        
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>
        
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>
        
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>
        
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>



    <!-- ======================== Ch:  ======================== -->
    <h3>Ch: </h3>
    <div>
        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>

        <h4></h4>
        <p></p>
    </div>
</body>
</html>